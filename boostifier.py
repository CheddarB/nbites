import templates

def process_message(message, known_messages, known_enums, scope_stack = []):
    """
    Recursively parse a tokenized protobuf message structure
    Returns a string that represents the boost wrapped code
    for the C++ classes generated by the message structure
    """

    result = ""
    other_wrapped_objects = []

    message_name = message.name
    scoped_message_name = scope(message.name, scope_stack)
    result += templates.MESSAGE_SCOPE
    scope_stack.append(message.name)

    result += templates.MESSAGE_DECLARATION % locals()

    for element in message.elements:
        if 'message' in element:
            other_wrapped_objects += [process_message(element, known_messages, known_enums, scope_stack)]
        elif 'enum' in element:
            other_wrapped_objects += [process_enum(element, scope_stack)]
        elif 'flavor' in element:
            result += process_field(element, known_messages, known_enums, scope_stack)
        else:
            raise 'Unknown type of element ' + str(element)

    result += templates.MESSAGE_DECLARATION_END

    for other_wrapped_object in other_wrapped_objects:
        result += other_wrapped_object

    scope_stack.pop()
    result += templates.MESSAGE_SCOPE_END

    return result

def process_enum(enum, scope_stack):

    result = ""

    enum_name = enum.name
    scoped_enum_name = scope(enum.name, scope_stack)
    result += templates.ENUM_DECLARATION % locals()

    for enum_field in enum.elements:
        enum_field_name = enum_field.name
        enum_field_value = scope(enum_field_name, scope_stack)
        result += templates.ENUM_FIELD % locals()

    result += templates.ENUM_DECLARATION_END
    return result

def process_field(element, known_messages, known_enums, scope_stack):

    string_format = ""

    if element.flavor == 'repeated':
        if element.type in known_messages:
            string_format = templates.REPEATED_MESSAGE
        elif element.type in ['string', 'bytes']:
            string_format = templates.REPEATED_STRING
        else:
            string_format = templates.REPEATED_PRIMITIVE
    else:
        if element.type in known_messages:
            string_format = templates.SINGLE_MESSAGE
        elif element.type in ['string', 'bytes']:
            string_format = templates.SINGLE_STRING
        else:
            string_format = templates.SINGLE_PRIMITIVE

    field_name = element.name.lower() # protoc converts fieldnames to lower
    field_type = element.type
    # should probably check straightaway against a primitive list rather
    # than just assume all types that are not known are primitives
    # but it's 3:30 AM and I don't wanna figure it out right now
    if (field_type not in known_messages) and (field_type not in known_enums) and (field_type not in ['string', 'bytes']):
        field_type = '::google::protobuf::' + field_type
    scope = '::'.join(scope_stack)
    return string_format % locals()

def scope(name, scope_list, delimiter = '::'):
    return delimiter.join(scope_list + [name])
